# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/005_FastKafkaServer.ipynb.

# %% auto 0
__all__ = ['FastKafkaServer', 'run_fastkafka_server']

# %% ../nbs/005_FastKafkaServer.ipynb 1
import importlib
import sys
import asyncio
from typing import *
from contextlib import contextmanager
from pathlib import Path
import threading
import signal

import multiprocessing

from .application import FastKafka
from .testing import change_dir
from ._components.helpers import generate_app_src, _import_from_string

# %% ../nbs/005_FastKafkaServer.ipynb 3
class FastKafkaServer:
    def __init__(self, app: FastKafka):
        self.app = app
        self.should_exit = False

    def run(self) -> None:
        return asyncio.run(self._serve())

    async def _serve(self) -> None:
        self._install_signal_handlers()

        async with app():
            await self._main_loop()

    def _install_signal_handlers(self) -> None:
        if threading.current_thread() is not threading.main_thread():
            # Signals can only be listened to from the main thread.
            return

        loop = asyncio.get_event_loop()

        HANDLED_SIGNALS = (
            signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.
            signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.
        )

        def handle_exit(sig: int) -> None:
            self.should_exit = True

        for sig in HANDLED_SIGNALS:
            loop.add_signal_handler(sig, handle_exit, sig)

    async def _main_loop(self) -> None:
        while not self.should_exit:
            await asyncio.sleep(0.1)

# %% ../nbs/005_FastKafkaServer.ipynb 5
@contextmanager
def run_fastkafka_server(app: FastKafka) -> Generator[None, None, None]:
    app = app

    def run(app=app):
        server = FastKafkaServer(app=app)
        server.run()

    p = multiprocessing.Process(target=run)
    try:
        p.start()
        yield
    except Exception as e:
        print(f"Exception raised {e=}")
    finally:
        p.terminate()
        p.join()
        p.close()
