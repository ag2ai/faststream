# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/005_FastKafkaServer.ipynb.

# %% auto 0
__all__ = ['logger', 'generate_app_in_tmp', 'ServerProcess', 'run_fastkafka_server_process', 'terminate_asyncio_process',
           'run_fastkafka_server', 'run_in_process']

# %% ../nbs/005_FastKafkaServer.ipynb 1
import importlib
import sys
import asyncio
from typing import *
from contextlib import contextmanager
from pathlib import Path
import threading
import signal
from contextlib import ExitStack, contextmanager
from tempfile import TemporaryDirectory


import multiprocessing
from fastcore.meta import delegates
from fastcore.basics import patch
import typer
import asyncer

from .application import FastKafka
from .testing import change_dir
from ._components.helpers import _import_from_string, generate_app_src
from ._components.logger import get_logger

# %% ../nbs/005_FastKafkaServer.ipynb 5
logger = get_logger(__name__)

# %% ../nbs/005_FastKafkaServer.ipynb 8
@contextmanager
def generate_app_in_tmp() -> Generator[str, None, None]:
    """Generate an app in a temporary directory

    Args:
        None

    Returns:
        A generator that yields the import string for the app

    Raises:
        None

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """
    with TemporaryDirectory() as d:
        src_path = Path(d) / "main.py"
        generate_app_src(src_path)
        with change_dir(d):
            import_str = f"{src_path.stem}:kafka_app"
            yield import_str

# %% ../nbs/005_FastKafkaServer.ipynb 9
class ServerProcess:
    """A class to represent a server process.

    Attributes:
        app : the app to run
        should_exit : whether the server should exit

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """

    def __init__(self, app: str):
        """Initialize the application

        Args:
            app: The name of the application

        !!! note

            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
        """
        self.app = app
        self.should_exit = False

    def run(self) -> None:
        """!!! note

        Failed to generate docs

        !!! note

            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
        """
        return asyncio.run(self._serve())

    async def _serve(self) -> None:
        """!!! note

        Failed to generate docs

        !!! note

            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
        """
        self._install_signal_handlers()

        self.application = _import_from_string(self.app)

        async with self.application:
            await self._main_loop()

    def _install_signal_handlers(self) -> None:
        """Install signal handlers for the current process.

        This method is not thread-safe. It must only be called from the main thread,
        before any other threads have been created.

        Args:
            sig: The signal to handle

        Raises:
            RuntimeError: If called from a thread other than the main thread.

        !!! note

            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
        """
        if threading.current_thread() is not threading.main_thread():
            raise RuntimeError()

        loop = asyncio.get_event_loop()

        HANDLED_SIGNALS = (
            signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.
            signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.
        )

        def handle_exit(sig: int) -> None:
            """Handle exit signal

            Args:
                sig: The signal to handle

            !!! note

                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
            """
            self.should_exit = True

        for sig in HANDLED_SIGNALS:
            loop.add_signal_handler(sig, handle_exit, sig)

    async def _main_loop(self) -> None:
        """!!! note

        Failed to generate docs

        !!! note

            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
        """
        while not self.should_exit:
            await asyncio.sleep(0.1)

# %% ../nbs/005_FastKafkaServer.ipynb 10
_app = typer.Typer()


@_app.command()
def run_fastkafka_server_process(
    app: str = typer.Argument(
        ...,
        help="input in the form of 'path:app', where **path** is the path to a python file and **app** is an object of type **FastKafka**.",
    )
) -> None:
    """Run a FastKafka server process.

    Args:
        app: input in the form of 'path:app', where **path** is the path to a python file and **app** is an object of type **FastKafka**.

    Returns:
        None

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """
    ServerProcess(app).run()

# %% ../nbs/005_FastKafkaServer.ipynb 12
async def terminate_asyncio_process(p: asyncio.subprocess.Process) -> None:
    """Terminate an asyncio process.

    Args:
        p: The process to terminate

    Returns:
        None

    Raises:
        asyncio.TimeoutError: If the process does not terminate

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """
    logger.info(f"terminate_asyncio_process(): Terminating the process {p.pid}...")
    # Check if SIGINT already propagated to process
    try:
        await asyncio.wait_for(p.wait(), 1)
        logger.info(
            f"terminate_asyncio_process(): Process {p.pid} was already terminated."
        )
        return
    except asyncio.TimeoutError:
        pass

    for i in range(3):
        p.terminate()
        try:
            await asyncio.wait_for(p.wait(), 10)
            logger.info(f"terminate_asyncio_process(): Process {p.pid} terminated.")
            return
        except asyncio.TimeoutError:
            logger.warning(
                f"terminate_asyncio_process(): Process {p.pid} not terminated, retrying..."
            )

    logger.warning(f"Killing the process {p.pid}...")
    p.kill()
    await p.wait()
    logger.warning(f"terminate_asyncio_process(): Process {p.pid} killed!")

# %% ../nbs/005_FastKafkaServer.ipynb 14
async def run_fastkafka_server(num_workers: int, app: str) -> None:
    """Run a fastkafka server.

    Args:
        num_workers: Number of workers
        app: The app to run

    Returns:
        None

    Raises:
        RuntimeError: If output is None
        typer.Exit: If returncodes are not all zero

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """
    loop = asyncio.get_event_loop()

    HANDLED_SIGNALS = (
        signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.
        signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.
    )

    d = {"should_exit": False}

    def handle_exit(sig: int, d: Dict[str, bool] = d) -> None:
        """Handle exit signal

        Args:
            sig: The signal number
            d: A dictionary containing the key "should_exit"

        Returns:
            None

        !!! note

            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
        """
        d["should_exit"] = True

    for sig in HANDLED_SIGNALS:
        loop.add_signal_handler(sig, handle_exit, sig)

    async with asyncer.create_task_group() as tg:
        tasks = [
            tg.soonify(asyncio.create_subprocess_exec)(
                "run_fastkafka_server_process",
                app,
                stdout=asyncio.subprocess.PIPE,
                stdin=asyncio.subprocess.PIPE,
            )
            for i in range(num_workers)
        ]

    procs = [task.value for task in tasks]

    async def log_output(
        output: Optional[asyncio.StreamReader], pid: int, d: Dict[str, bool] = d
    ) -> None:
        """Logs the output of a process.

        Args:
            output: The output of the process
            pid: The process id
            d: A dictionary of booleans

        Raises:
            RuntimeError: If output is None

        !!! note

            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
        """
        if output is None:
            raise RuntimeError("Expected StreamReader, got None. Is stdout piped?")
        while not output.at_eof():
            outs = await output.readline()
            if outs != b"":
                typer.echo(f"[{pid:03d}]: " + outs.decode("utf-8"), nl=False)

    async with asyncer.create_task_group() as tg:
        for proc in procs:
            tg.soonify(log_output)(proc.stdout, proc.pid)

        while not d["should_exit"]:
            await asyncio.sleep(0.2)

        typer.echo("Starting process cleanup, this may take a few seconds...")
        for proc in procs:
            tg.soonify(terminate_asyncio_process)(proc)

    for proc in procs:
        output, _ = await proc.communicate()
        if output:
            typer.echo(f"[{proc.pid:03d}]: " + output.decode("utf-8"), nl=False)

    returncodes = [proc.returncode for proc in procs]
    if not returncodes == [0] * len(procs):
        typer.secho(
            f"Return codes are not all zero: {returncodes}",
            err=True,
            fg=typer.colors.RED,
        )
        raise typer.Exit(1)

# %% ../nbs/005_FastKafkaServer.ipynb 15
@contextmanager
def run_in_process(
    target: Callable[..., Any]
) -> Generator[multiprocessing.Process, None, None]:
    """Run a function in a separate process.

    Args:
        target: The function to run in a separate process.

    Returns:
        A generator that yields a process.

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """
    p = multiprocessing.Process(target=target)
    try:
        p.start()
        yield p
    except Exception as e:
        print(f"Exception raised {e=}")
    finally:
        p.terminate()
        p.join()
