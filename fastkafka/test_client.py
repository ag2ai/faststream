# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/9991_Test_Client.ipynb.

# %% auto 0
__all__ = ['AwaitedMock', 'Tester', 'mirror_producer', 'mirror_consumer']

# %% ../nbs/9991_Test_Client.ipynb 1
from collections import namedtuple
from unittest.mock import AsyncMock, MagicMock
from typing import *
import inspect
import functools
from datetime import datetime, timedelta
import asyncio

from fastcore.foundation import patch
from fastcore.meta import delegates

from .application import FastKafka

# %% ../nbs/9991_Test_Client.ipynb 3
class AwaitedMock:
    @staticmethod
    def _await_for(f: Callable[[...], Any]) -> Callable[[...], Any]:
        @delegates(f)
        async def inner(*args, f=f, timeout: int = 60, **kwargs) -> Any:
            if inspect.iscoroutinefunction(f):
                return await asyncio.wait_for(f(*args, **kwargs), timeout=timeout)
            else:
                t0 = datetime.now()
                e: Optional[Exception] = None
                while datetime.now() - t0 < timedelta(seconds=timeout):
                    try:
                        return f(*args, **kwargs)
                    except Exception as _e:
                        await asyncio.sleep(1)
                        e = _e
                raise e

        return inner

    def __init__(self, o: Any):
        self._o = o

        for name in o.__dir__():
            if not name.startswith("_"):
                f = getattr(o, name)
                if inspect.ismethod(f):
                    setattr(self, name, self._await_for(f))

# %% ../nbs/9991_Test_Client.ipynb 4
@patch
def create_mocks(self: FastKafka) -> None:
    """Creates self.mocks as a named tuple mapping a new function obtained by calling the original functions and a mock"""
    app_methods = [f for f, _ in self._consumers_store.values()] + [
        f for f, _, _ in self._producers_store.values()
    ]
    self.AppMocks = namedtuple(
        f"{self.__class__.__name__}Mocks", [f.__name__ for f in app_methods]
    )

    self.mocks = self.AppMocks(
        **{
            f.__name__: AsyncMock() if inspect.iscoroutinefunction(f) else MagicMock()
            for f in app_methods
        }
    )

    self.awaited_mocks = self.AppMocks(
        **{name: AwaitedMock(mock) for name, mock in self.mocks._asdict().items()}
    )

    def add_mock(
        f: Callable[[...], Any], mock: Union[AsyncMock, MagicMock]
    ) -> Callable[[...], Any]:
        """Add call to mock when calling function f"""

        @functools.wraps(f)
        async def async_inner(
            *args, f: Callable[[...], Any] = f, mock: AsyncMock = mock, **kwargs
        ) -> Any:
            await mock(*args, **kwargs)
            return await f(*args, **kwargs)

        @functools.wraps(f)
        def sync_inner(
            *args, f: Callable[[...], Any] = f, mock: MagicMock = mock, **kwargs
        ) -> Any:
            mock(*args, **kwargs)
            return f(*args, **kwargs)

        if inspect.iscoroutinefunction(f):
            return async_inner
        else:
            return sync_inner

    self._consumers_store = {
        name: (
            add_mock(f, getattr(self.mocks, f.__name__)),
            kwargs,
        )
        for name, (f, kwargs) in self._consumers_store.items()
    }
    self._producers_store = {
        name: (
            add_mock(f, getattr(self.mocks, f.__name__)),
            producer,
            kwargs,
        )
        for name, (f, producer, kwargs) in self._producers_store.items()
    }

# %% ../nbs/9991_Test_Client.ipynb 9
class Tester(FastKafka):
    def __init__(self, app: Union[FastKafka, List[FastKafka]]):
        self.apps = app if isinstance(app, list) else [app]
        super().__init__(
            bootstrap_servers=self.apps[0]._kafka_config["bootstrap_servers"]
        )
        self.create_mirrors()

    async def startup(self):
        for app in self.apps:
            app.create_mocks()
            await app.startup()

        self.create_mocks()
        await super().startup()
        await asyncio.sleep(3)

    async def shutdown(self):
        await super().shutdown()
        for app in self.apps[::-1]:
            await app.shutdown()

    def create_mirrors(self):
        pass

# %% ../nbs/9991_Test_Client.ipynb 12
def mirror_producer(
    topic: str, producer_f: Callable[[...], Any]
) -> Callable[[...], Any]:
    msg_type = inspect.signature(producer_f).return_annotation

    async def skeleton_func(msg):
        pass

    mirror_func = skeleton_func
    sig = inspect.signature(skeleton_func)

    # adjust name
    mirror_func.__name__ = "on_" + topic

    # adjust arg and return val
    sig = sig.replace(
        parameters=[
            inspect.Parameter(
                name="msg",
                annotation=msg_type,
                kind=inspect.Parameter.POSITIONAL_OR_KEYWORD,
            )
        ]
    )

    mirror_func.__signature__ = sig

    return mirror_func

# %% ../nbs/9991_Test_Client.ipynb 14
def mirror_consumer(
    topic: str, consumer_f: Callable[[...], Any]
) -> Callable[[...], Any]:
    msg_type = inspect.signature(consumer_f).parameters["msg"]

    async def skeleton_func(msg):
        return msg

    mirror_func = skeleton_func
    sig = inspect.signature(skeleton_func)

    # adjust name
    mirror_func.__name__ = "to_" + topic

    # adjust arg and return val
    sig = sig.replace(parameters=[msg_type], return_annotation=msg_type.annotation)

    mirror_func.__signature__ = sig
    return mirror_func

# %% ../nbs/9991_Test_Client.ipynb 16
@patch
def create_mirrors(self: Tester):
    for app in self.apps:
        for topic, (consumer_f, _) in app._consumers_store.items():
            mirror_f = mirror_consumer(topic, consumer_f)
            mirror_f = self.produces()(mirror_f)
            setattr(self, mirror_f.__name__, mirror_f)
        for topic, (producer_f, _, _) in app._producers_store.items():
            mirror_f = mirror_producer(topic, producer_f)
            mirror_f = self.consumes()(mirror_f)
            setattr(self, mirror_f.__name__, mirror_f)
