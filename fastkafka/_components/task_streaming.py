# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/011_TaskStreaming.ipynb.

# %% auto 0
__all__ = ['logger', 'TaskPool', 'ExceptionMonitor', 'TaskStream', 'CoroutineStream']

# %% ../../nbs/011_TaskStreaming.ipynb 1
import asyncio

from asyncio import Task
from contextlib import asynccontextmanager
from typing import *

import anyio

from .logger import get_logger

# %% ../../nbs/011_TaskStreaming.ipynb 3
logger = get_logger(__name__)

# %% ../../nbs/011_TaskStreaming.ipynb 10
class TaskPool:
    def __init__(
        self,
        size: int = 100_000,
        on_error: Optional[Callable[[BaseException], None]] = None,
    ):
        self.size = size
        self.pool: Set[Task] = set()
        self.on_error = on_error
        self.finished = False

    async def add(self, item: Task) -> None:
        while len(self.pool) >= self.size:
            await asyncio.sleep(0)
        self.pool.add(item)
        item.add_done_callback(self.discard)

    def discard(self, task: Task) -> None:
        e = task.exception()
        if e is not None and self.on_error is not None:
            try:
                self.on_error(e)
            except Exception as ee:
                logger.warning(
                    f"Exception {ee} raised when calling on_error() callback: {e}"
                )

        self.pool.discard(task)

    def __len__(self) -> int:
        return len(self.pool)

    async def __aenter__(self) -> "TaskPool":
        self.finished = False
        return self

    async def __aexit__(self, *args: Any, **kwargs: Any) -> None:
        while len(self) > 0:
            await asyncio.sleep(0)
        self.finished = True

    @staticmethod
    def log_error(logger: "logging.Logger") -> Callable[[Exception], None]:
        def _log_error(e: Exception, logger: "logging.Logger" = logger) -> None:
            logger.warning(f"{e=}")

        return _log_error

# %% ../../nbs/011_TaskStreaming.ipynb 14
class ExceptionMonitor:
    def __init__(self):
        self.exceptions = []
        self.exception_found = False

    def on_error(self, e: Exception) -> None:
        self.exceptions.append(e)
        self.exception_found = True

    def _monitor_step(self) -> None:
        if len(self.exceptions) > 0:
            e = self.exceptions.pop(0)
            raise e

    async def __aenter__(self) -> "ExceptionMonitor":
        return self

    async def __aexit__(self, a, b, c) -> None:
        while len(self.exceptions) > 0:
            self._monitor_step()
            await asyncio.sleep(0)

# %% ../../nbs/011_TaskStreaming.ipynb 18
class TaskStream:
    def __init__(
        self,
        produce_func,
        consume_func,
        throw_exceptions: bool = True,
        max_buffer_size=100_000,
        size=100_000,
    ):
        self.produce_func = produce_func
        self.consume_func = consume_func
        self.throw_exceptions = throw_exceptions
        self.max_buffer_size = max_buffer_size
        self.exception_monitor = ExceptionMonitor()
        self.task_pool = TaskPool(
            on_error=self.exception_monitor.on_error
            if throw_exceptions
            else TaskPool.log_error(logger),
            size=size,
        )

    def _process_items(self):
        async def _process_items_wrapper(
            receive_stream, consume_func=self.consume_func, task_pool=self.task_pool
        ):
            async with receive_stream:
                async for msg in receive_stream:
                    task = asyncio.create_task(consume_func(msg))
                    await task_pool.add(task)

        return _process_items_wrapper

    async def start(self, is_shutting_down_f):
        send_stream, receive_stream = anyio.create_memory_object_stream(
            max_buffer_size=self.max_buffer_size
        )

        async with self.exception_monitor, self.task_pool:
            async with anyio.create_task_group() as tg:
                tg.start_soon(self._process_items(), receive_stream)
                async with send_stream:
                    while not is_shutting_down_f():
                        if self.exception_monitor.exception_found and throw_exceptions:
                            break
                        msgs = await self.produce_func()
                        for msg in msgs:
                            await send_stream.send(msg)

# %% ../../nbs/011_TaskStreaming.ipynb 27
class CoroutineStream:
    def __init__(
        self,
        produce_func,
        consume_func,
        throw_exceptions: bool = True,
        max_buffer_size=100_000,
    ):
        self.produce_func = produce_func
        self.consume_func = consume_func
        self.throw_exceptions = throw_exceptions
        self.max_buffer_size = max_buffer_size

    def _process_items(self):
        async def _process_items_wrapper(
            receive_stream,
            consume_func=self.consume_func,
            throw_exceptions=self.throw_exceptions,
        ):
            async with receive_stream:
                async for msg in receive_stream:
                    try:
                        await consume_func(msg)
                    except Exception as e:
                        if throw_exceptions:
                            raise e
                        else:
                            logger.warning(f"{e=}")

        return _process_items_wrapper

    async def start(self, is_shutting_down_f):
        send_stream, receive_stream = anyio.create_memory_object_stream(
            max_buffer_size=self.max_buffer_size
        )

        async with anyio.create_task_group() as tg:
            tg.start_soon(self._process_items(), receive_stream)
            async with send_stream:
                while not is_shutting_down_f():
                    msgs = await self.produce_func()
                    for msg in msgs:
                        await send_stream.send(msg)
